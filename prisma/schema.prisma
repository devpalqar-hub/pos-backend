// This is your Prisma schema file,
// learn more about it in the dnpmnpocs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

// ─── Enums ────────────────────────────────────────────────────────────────────

enum UserRole {
  SUPER_ADMIN
  OWNER
  RESTAURANT_ADMIN
  WAITER
  CHEF
  BILLER
}

enum DayOfWeek {
  MONDAY
  TUESDAY
  WEDNESDAY
  THURSDAY
  FRIDAY
  SATURDAY
  SUNDAY
}

enum ItemType {
  STOCKABLE // Stock-tracked — goes OOS when count hits 0
  NON_STOCKABLE // No count — manually marked OOS per day, auto-resets next day
}

enum PriceRuleType {
  RECURRING_WEEKLY // Repeats every week on the specified day(s) + time window
  LIMITED_TIME // Active only within a specific calendar date range
}

enum TableStatus {
  AVAILABLE
  OCCUPIED
  RESERVED
  CLEANING
}

enum OrderChannel {
  DINE_IN // In-restaurant table service
  ONLINE_OWN // Own online ordering platform
  UBER_EATS // Uber Eats integration
}

enum SessionStatus {
  OPEN // Active — accepting new items
  BILLED // Bill generated, awaiting payment
  PAID // Fully settled and closed
  CANCELLED // Cancelled before billing
  VOID // Admin-voided after billing
}

enum BatchStatus {
  PENDING // Submitted to kitchen, not started
  IN_PROGRESS // Chef actively working on items
  READY // All items prepared, awaiting service
  SERVED // All items delivered to customer
}

enum OrderItemStatus {
  PENDING // Queued in kitchen
  PREPARING // Chef is working on it (optional)
  PREPARED // Ready for pickup / serving (optional)
  SERVED // Delivered to customer
  CANCELLED // Item cancelled after ordering
}

enum BillStatus {
  DRAFT // Auto-calculated, not locked
  FINAL // Locked, ready for payment
  PAID // Fully settled
  VOIDED // Voided by staff
}

enum PaymentMethod {
  CASH
  CARD
  UPI
  ONLINE
  OTHER
}

// ─── Models ───────────────────────────────────────────────────────────────────

model User {
  id           String   @id @default(uuid())
  name         String   @db.VarChar(255)
  email        String   @unique @db.VarChar(255)
  role         UserRole @default(WAITER)
  isActive     Boolean  @default(true)
  createdById  String?
  restaurantId String?
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  // Self-referential: who created this user
  createdBy    User?  @relation("CreatedByUser", fields: [createdById], references: [id])
  createdUsers User[] @relation("CreatedByUser")

  // Restaurant this user is ASSIGNED to (staff members)
  restaurant Restaurant? @relation("RestaurantStaff", fields: [restaurantId], references: [id])

  // Restaurants this user OWNS (only for OWNER role)
  ownedRestaurants Restaurant[] @relation("RestaurantOwner")

  // Restaurants this user CREATED (only SUPER_ADMIN)
  createdRestaurants Restaurant[] @relation("RestaurantCreatedBy")

  // ── Order backward relations ──────────────────────────────────────────────
  openedSessions    OrderSession[] @relation("SessionOpenedBy")
  createdBatches    OrderBatch[]   @relation("BatchCreatedBy")
  generatedBills    Bill[]         @relation("BillGeneratedBy")
  processedPayments Payment[]      @relation("PaymentProcessedBy")

  @@map("users")
}

model Restaurant {
  id          String  @id @default(uuid())
  name        String  @db.VarChar(255)
  slug        String  @unique @db.VarChar(255)
  description String? @db.Text

  // Ownership & creation
  ownerId     String
  createdById String?

  // Contact
  phone   String? @db.VarChar(30)
  email   String? @db.VarChar(255)
  website String? @db.VarChar(500)

  // Location
  address    String?  @db.VarChar(500)
  city       String?  @db.VarChar(100)
  state      String?  @db.VarChar(100)
  country    String?  @db.VarChar(100)
  postalCode String?  @db.VarChar(20)
  latitude   Decimal? @db.Decimal(10, 8)
  longitude  Decimal? @db.Decimal(11, 8)

  // Branding
  logoUrl  String? @db.VarChar(1000)
  coverUrl String? @db.VarChar(1000)

  // Business details
  cuisineType String?  @db.VarChar(255)
  maxCapacity Int?
  taxRate     Decimal? @db.Decimal(5, 2)
  currency    String   @default("USD") @db.VarChar(10)

  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  owner     User   @relation("RestaurantOwner", fields: [ownerId], references: [id])
  createdBy User?  @relation("RestaurantCreatedBy", fields: [createdById], references: [id])
  staff     User[] @relation("RestaurantStaff")

  workingHours   WorkingHours[]
  categories     MenuCategory[]
  menuItems      MenuItem[]
  priceRules     PriceRule[]
  tableGroups    TableGroup[]
  tables         Table[]
  sessions       OrderSession[]
  bills          Bill[]
  customers      Customer[]
  loyalityPoints LoyalityPoint[]

  @@index([ownerId])
  @@map("restaurants")
}

model WorkingHours {
  id           String    @id @default(uuid())
  restaurantId String
  day          DayOfWeek
  openTime     String?   @db.VarChar(10) // "09:00" (24-hr format)
  closeTime    String?   @db.VarChar(10) // "22:00"
  isClosed     Boolean   @default(false)
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt

  restaurant Restaurant @relation(fields: [restaurantId], references: [id], onDelete: Cascade)

  @@unique([restaurantId, day])
  @@map("working_hours")
}

// ─── Menu Category ───────────────────────────────────────────────────────────

model MenuCategory {
  id           String   @id @default(uuid())
  restaurantId String
  name         String   @db.VarChar(255)
  description  String?  @db.Text
  imageUrl     String?  @db.VarChar(1000)
  isActive     Boolean  @default(true)
  sortOrder    Int      @default(0)
  createdById  String?
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  restaurant     Restaurant      @relation(fields: [restaurantId], references: [id], onDelete: Cascade)
  items          MenuItem[]
  loyalityPoints LoyalityPoint[]

  @@unique([restaurantId, name])
  @@index([restaurantId])
  @@map("menu_categories")
}

// ─── Menu Item ────────────────────────────────────────────────────────────────

model MenuItem {
  id              String   @id @default(uuid())
  restaurantId    String
  categoryId      String
  name            String   @db.VarChar(255)
  description     String?  @db.Text
  price           Decimal  @db.Decimal(10, 2)
  discountedPrice Decimal? @db.Decimal(10, 2)
  imageUrl        String?  @db.VarChar(1000)
  itemType        ItemType @default(NON_STOCKABLE)

  // STOCKABLE only — tracks remaining stock units
  stockCount Int? @default(0)

  // Availability flags
  isAvailable  Boolean   @default(true) // master toggle (soft-delete)
  isOutOfStock Boolean   @default(false) // transient — flipped by stock actions
  outOfStockAt DateTime? // timestamp when last marked OOS

  isActive    Boolean  @default(true)
  sortOrder   Int      @default(0)
  createdById String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  restaurant     Restaurant      @relation(fields: [restaurantId], references: [id], onDelete: Cascade)
  category       MenuCategory    @relation(fields: [categoryId], references: [id])
  priceRules     PriceRule[]
  orderItems     OrderItem[]
  billItems      BillItem[]
  loyalityPoints LoyalityPoint[]

  @@index([restaurantId])
  @@index([categoryId])
  @@map("menu_items")
}

// ─── Price Rules ─────────────────────────────────────────────────────────────
// Overrides the menu item's base price during a specific time window.
// Two rule types:
//   RECURRING_WEEKLY — activates every week on the listed days within startTime–endTime
//   LIMITED_TIME     — activates only between startDate and endDate, optionally within startTime–endTime

model PriceRule {
  id           String @id @default(uuid())
  restaurantId String
  menuItemId   String

  name         String        @db.VarChar(255) // e.g. "Happy Hour", "Monday Morning Promo"
  ruleType     PriceRuleType
  specialPrice Decimal       @db.Decimal(10, 2) // The override price when rule is active

  // ── Time window (24-hr HH:MM) ─────────────────────────────────────────────
  // null startTime / endTime  = applies all day.
  startTime String? @db.VarChar(10) // e.g. "09:00"
  endTime   String? @db.VarChar(10) // e.g. "11:00"

  // ── LIMITED_TIME only ─────────────────────────────────────────────────────
  startDate DateTime? // Rule becomes active on/after this date
  endDate   DateTime? // Rule expires after this date

  // ── RECURRING_WEEKLY only ─────────────────────────────────────────────────
  // Days are stored in PriceRuleDay (one row per day)

  priority    Int      @default(0) // Higher number wins when rules overlap
  isActive    Boolean  @default(true)
  createdById String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  restaurant Restaurant     @relation(fields: [restaurantId], references: [id], onDelete: Cascade)
  menuItem   MenuItem       @relation(fields: [menuItemId], references: [id], onDelete: Cascade)
  days       PriceRuleDay[]

  @@index([restaurantId])
  @@index([menuItemId])
  @@map("price_rules")
}

model PriceRuleDay {
  id     String    @id @default(uuid())
  ruleId String
  day    DayOfWeek

  rule PriceRule @relation(fields: [ruleId], references: [id], onDelete: Cascade)

  @@unique([ruleId, day])
  @@map("price_rule_days")
}

// ─── Table Group ─────────────────────────────────────────────────────────────
// Optional grouping of tables to represent sections / floors in the restaurant.

model TableGroup {
  id           String   @id @default(uuid())
  restaurantId String
  name         String   @db.VarChar(255) // e.g. "Ground Floor", "Rooftop", "Section A"
  description  String?  @db.Text
  color        String?  @db.VarChar(20) // UI hint, e.g. "#FF5733"
  sortOrder    Int      @default(0)
  isActive     Boolean  @default(true)
  createdById  String?
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  restaurant Restaurant @relation(fields: [restaurantId], references: [id], onDelete: Cascade)
  tables     Table[]

  @@unique([restaurantId, name])
  @@index([restaurantId])
  @@map("table_groups")
}

// ─── Table ────────────────────────────────────────────────────────────────────

model Table {
  id           String  @id @default(uuid())
  restaurantId String
  groupId      String? // Optional — table may not belong to any group

  name        String      @db.VarChar(255) // e.g. "T1", "Table 1"
  seatCount   Int // Number of seats
  status      TableStatus @default(AVAILABLE) // Real-time occupancy status
  isActive    Boolean     @default(true)
  createdById String?
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt

  restaurant Restaurant     @relation(fields: [restaurantId], references: [id], onDelete: Cascade)
  group      TableGroup?    @relation(fields: [groupId], references: [id], onDelete: SetNull)
  sessions   OrderSession[]

  @@unique([restaurantId, name])
  @@index([restaurantId])
  @@index([groupId])
  @@map("tables")
}

// ─── Orders ──────────────────────────────────────────────────────────────────
// Flow: OrderSession → OrderBatch → OrderItem → Bill → Payment
// Each session is a "tab" on a table. Multiple OPEN sessions per table are
// allowed to support split-bill / separate-party scenarios.

model OrderSession {
  id           String  @id @default(uuid())
  restaurantId String
  tableId      String? // null for online / delivery orders

  sessionNumber String        @db.VarChar(6) // 6-char alphanumeric, unique per restaurant
  channel       OrderChannel  @default(DINE_IN)
  status        SessionStatus @default(OPEN)

  // ── Walk-in customer info (NOT a system User) ───────────────────────────
  customerName  String? @db.VarChar(255)
  customerPhone String? @db.VarChar(30)
  customerEmail String? @db.VarChar(255)
  guestCount    Int     @default(1)

  // ── Online / delivery fields (ONLINE_OWN & UBER_EATS channels) ──────────
  externalOrderId     String?  @db.VarChar(255) // Uber Eats order ID, etc.
  externalChannel     String?  @db.VarChar(100) // Raw channel label from integration
  deliveryAddress     String?  @db.Text
  deliveryFee         Decimal? @db.Decimal(10, 2)
  specialInstructions String?  @db.Text

  // ── Pricing snapshot (populated when bill is generated) ─────────────────
  subtotal       Decimal? @db.Decimal(10, 2)
  taxAmount      Decimal? @db.Decimal(10, 2)
  discountAmount Decimal? @db.Decimal(10, 2)
  totalAmount    Decimal? @db.Decimal(10, 2)

  openedById String
  closedAt   DateTime?
  createdAt  DateTime  @default(now())
  updatedAt  DateTime  @updatedAt

  restaurant Restaurant   @relation(fields: [restaurantId], references: [id], onDelete: Cascade)
  table      Table?       @relation(fields: [tableId], references: [id], onDelete: SetNull)
  openedBy   User         @relation("SessionOpenedBy", fields: [openedById], references: [id])
  batches    OrderBatch[]
  bill       Bill?

  @@unique([restaurantId, sessionNumber])
  @@index([restaurantId])
  @@index([tableId])
  @@index([status])
  @@map("order_sessions")
}

model OrderBatch {
  id          String      @id @default(uuid())
  sessionId   String
  batchNumber String      @db.VarChar(6) // 6-char alphanumeric, unique per session
  status      BatchStatus @default(PENDING)
  notes       String?     @db.Text // Kitchen-level notes for the whole batch

  createdById String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  session   OrderSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  createdBy User?        @relation("BatchCreatedBy", fields: [createdById], references: [id])
  items     OrderItem[]

  @@unique([sessionId, batchNumber])
  @@index([sessionId])
  @@index([status])
  @@map("order_batches")
}

model OrderItem {
  id         String @id @default(uuid())
  batchId    String
  menuItemId String

  quantity   Int     @default(1)
  unitPrice  Decimal @db.Decimal(10, 2) // Price snapshot at time of order
  totalPrice Decimal @db.Decimal(10, 2) // unitPrice × quantity
  notes      String? @db.VarChar(500) // Per-item instructions

  status       OrderItemStatus @default(PENDING)
  preparedAt   DateTime?
  servedAt     DateTime?
  cancelledAt  DateTime?
  cancelReason String?         @db.VarChar(500)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  batch    OrderBatch @relation(fields: [batchId], references: [id], onDelete: Cascade)
  menuItem MenuItem   @relation(fields: [menuItemId], references: [id])

  @@index([batchId])
  @@index([menuItemId])
  @@index([status])
  @@map("order_items")
}

// ─── Billing ─────────────────────────────────────────────────────────────────

model Bill {
  id           String     @id @default(uuid())
  sessionId    String     @unique
  restaurantId String
  billNumber   String     @db.VarChar(6) // 6-char alphanumeric, unique per restaurant
  status       BillStatus @default(DRAFT)

  subtotal       Decimal @db.Decimal(10, 2)
  taxRate        Decimal @db.Decimal(5, 2)
  taxAmount      Decimal @db.Decimal(10, 2)
  discountAmount Decimal @default(0) @db.Decimal(10, 2)
  totalAmount    Decimal @db.Decimal(10, 2)

  notes         String?   @db.Text
  generatedById String?
  paidAt        DateTime?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  session     OrderSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  restaurant  Restaurant   @relation(fields: [restaurantId], references: [id], onDelete: Cascade)
  generatedBy User?        @relation("BillGeneratedBy", fields: [generatedById], references: [id])
  items       BillItem[]
  payments    Payment[]

  @@unique([restaurantId, billNumber])
  @@index([restaurantId])
  @@index([status])
  @@map("bills")
}

model BillItem {
  id         String @id @default(uuid())
  billId     String
  menuItemId String

  name       String  @db.VarChar(255) // Snapshot of menu item name at billing time
  quantity   Int
  unitPrice  Decimal @db.Decimal(10, 2)
  totalPrice Decimal @db.Decimal(10, 2)

  bill     Bill     @relation(fields: [billId], references: [id], onDelete: Cascade)
  menuItem MenuItem @relation(fields: [menuItemId], references: [id])

  @@index([billId])
  @@map("bill_items")
}

model Payment {
  id        String        @id @default(uuid())
  billId    String
  amount    Decimal       @db.Decimal(10, 2)
  method    PaymentMethod
  reference String?       @db.VarChar(255) // Transaction ID, UPI ref, card last4, etc.
  notes     String?       @db.VarChar(500)

  processedById String?
  createdAt     DateTime @default(now())

  bill        Bill  @relation(fields: [billId], references: [id], onDelete: Cascade)
  processedBy User? @relation("PaymentProcessedBy", fields: [processedById], references: [id])

  @@index([billId])
  @@map("payments")
}

model OtpToken {
  id        String   @id @default(uuid())
  email     String   @db.VarChar(255)
  otp       String   @db.VarChar(10)
  expiresAt DateTime
  isUsed    Boolean  @default(false)
  createdAt DateTime @default(now())

  @@index([email])
  @@map("otp_tokens")
}

// ─── Customer ────────────────────────────────────────────────────────────────

model Customer {
  id           String   @id @default(uuid())
  restaurantId String
  phone        String   @db.VarChar(30)
  name         String?  @db.VarChar(255)
  wallet       Decimal  @default(0) @db.Decimal(10, 2)
  isActive     Boolean  @default(true)
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  restaurant              Restaurant                @relation(fields: [restaurantId], references: [id], onDelete: Cascade)
  LoyalityPointRedemption LoyalityPointRedemption[]

  @@unique([restaurantId, phone])
  @@index([restaurantId])
  @@index([phone])
  @@map("customers")
}

// ─── Loyality Points ─────────────────────────────────────────────────────────

model LoyalityPoint {
  id           String  @id @default(uuid())
  restaurantId String
  isGroup      Boolean @default(false) //to make loyality point for single item and multiple item
  name         String  @db.VarChar(255)
  points       Decimal @default(0) @db.Decimal(10, 2) // Points awarded per qualifying purchase

  // ── Date range (optional) ─────────────────────────────────────────────────
  startDate DateTime?
  endDate   DateTime?

  // ── Time window (optional, 24-hr HH:MM) ──────────────────────────────────
  startTime String? @db.VarChar(10) // e.g. "09:00"
  endTime   String? @db.VarChar(10) // e.g. "22:00"

  // ── Max redemptions per customer (optional) ───────────────────────────────
  maxUsagePerCustomer Int? // null = unlimited

  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  restaurant Restaurant         @relation(fields: [restaurantId], references: [id], onDelete: Cascade)
  categories MenuCategory[]
  menuItems  MenuItem[]
  days       LoyalityPointDay[]

  redemptions LoyalityPointRedemption[]

  @@index([restaurantId])
  @@map("loyality_points")
}

model LoyalityPointDay {
  id              String    @id @default(uuid())
  loyalityPointId String
  day             DayOfWeek

  loyalityPoint LoyalityPoint @relation(fields: [loyalityPointId], references: [id], onDelete: Cascade)

  @@unique([loyalityPointId, day])
  @@map("loyality_point_days")
}

model LoyalityPointRedemption {
  id              String @id @default(uuid())
  loyalityPointId String
  customerId      String

  pointsAwarded Decimal  @db.Decimal(10, 2)
  redeemedAt    DateTime @default(now())

  loyalityPoint LoyalityPoint @relation(fields: [loyalityPointId], references: [id], onDelete: Cascade)
  customer      Customer      @relation(fields: [customerId], references: [id], onDelete: Cascade)

  @@index([loyalityPointId])
  @@index([customerId])
  @@map("loyality_point_redemptions")
}
